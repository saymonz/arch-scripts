# pkgpicker
*ZSH* (!) script using *yay* and *fzf* to create a "graphical" console package picker.

I spend way too much time trying various softwares from Arch Linux repositories or the AUR. I find the search feature of *pacman* is overwhelming as soon as there is many results. Using this script, you can browse packages (with package informations in preview window) and filter packages by name on the fly. You can also select multiple packages with tab, etc.

It's used like this:

	$ ./pkgpicker <options> [// command]

Example:

	$ ./pkgpicker repo // yay -S --needed

This will give you a fzf loaded with every packages in the repositories. Once you finish your selection, it will be passed to *yay -S --needed* command for installation.

Of course, you could just pipe the results:

	$ ./pkgpicker repo | yay -S --needed

But it has a downside: if your command  exits you have no way to recover the selection you made. By using it my way the command that is executed is echo'd to the terminal before, which is good for me.

List of options available:
- **repo**: will list packages in the repositories
- **aur**: will list aur packages
- **local**: will list every installed packages
- **explicit**: will list explicitely installed packages
- **skipinstalled**: will filter out installed packages
- **skipbase**: will filter out packages from *base* and *base-devel* groups

Another example I like:

	$ ./pkgpicker explicit skipbase // yay -Rns 

As I love trying softwares, this can help me find things I installed for trying and remove them without getting lost in dependencies.



# systemd-boot-mkconfig
Bash script for autogeneration of systemd-boot entry files

Use at your own risk.

What is it doing exactly?

It detects installed kernels by looking at mkinitcpio presets (because it's the lazy way). For each preset, the script check if every needed files are indeed present in /boot, if so it makes 2 entries files: normal and fallback.

There is various settings on script beginning that you should edit:

 - **BOOT_PATH**: path to your */boot*. This script assume that your EFI partition is mounted as */boot*. If your's not, you will have to manually copy files from */boot* directory to the root of your EFI partition and point this there. If you're using *systemd-boot* with a non-standard mounting point for your EFI you probably know what you're doing anyway.
 - **LOADER_ENTRIES_PATH**: path to your *loader/entries* directory. By default it's in */boot*.
 - **OS_PRETTY_NAME**: will be the boot menu item text. By default, will be *Arch Linux* on... Arch Linux. It takes its value in */etc/os-release*.
 - **OS_ID**: will serve as prefix for generated filenames by default, along with the *MACHINE_ID*.
 - **MACHINE_ID**: specified in each entried as recommended in the systemd-boot specification. It's supposed to be a random string generated by your OS on installation. On the plus side, using it for prefixing the filenames avoid collision with files from another OS or manually crafted.
 - **ENTRY_FILENAME_PREFIX**: If you want to avoid ugly filenames or customize the prefix, be my guest.

And last but not least the two most important settings:
 - **KERN_CMDLINE_DEFAULT** and **KERN_CMDLINE_FALLBACK**: kernel parameters for booting respectively *default* (aka *it's working fine*) and *fallback* (aka *oooops*) entries. If you don't at least set your root mountpoint you're gonna have a bad time.

Run as *root* (or *sudo*). It should not modify anything else than the content of *LOADER_ENTRIES_PATH*, and only files with the specified *ENTRY_FILENAME_PREFIX*, so it MAY be safe.

I'm very new to Bash scripting so maybe your computer will explode, I take no responsability.
